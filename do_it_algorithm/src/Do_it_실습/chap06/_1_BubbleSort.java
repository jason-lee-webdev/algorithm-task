package Do_it_실습.chap06;

import java.util.Arrays;

//버블 정렬

//[예시]
//버블 정렬(버전 1)
//요솟수:7
//x[0]:6
//x[1]:4
//x[2]:3
//x[3]:7
//x[4]:1
//x[5]:9
//x[6]:8
//오름차순으로 정렬했습니다.
//x[0]:1
//x[1]:3
//x[2]:4
//x[3]:6
//x[4]:7
//x[5]:8
//x[6]:9

//[생각]
//요솟수가 n개인 배열에서 n-1번 비교, 교환 하고 나면 가장 작은 요소가 맨 처음으로 이동합니다.
//이런 일련의 과정(비교, 교환)을 패스(pass)라고 합니다.
//이어서 배열의 두 번째 이후 요소를 비교, 교환하는 패스를 수행합니다.
//이 패스를 수행하고 나면 3은 배열의 두 번째 자리로 이동하고 그 결과 두 요소의 정렬이 끝납니다.
//두 번째 패스의 비교 횟수는 첫 번째 패스보다 1번 적은 n-2번 입니다.
//왜냐하면 패스를 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문입니다.
//패스를 k번 수행하면 앞쪽부터 k개의 요소가 정렬된다는 것을 알 수 있습니다.
//모든 정렬이 끝나려면 패스가 n-1번 수행되어야 합니다.
//수행하는 패스의 횟수가 n번이 아니라 n-1번인 것은 n-1개의 요소의 정렬이 끝나면 마지막 요소는 이미 끝에 놓이기 떄문입니다.

public class _1_BubbleSort {

	public static void main(String[] args) {
		int[] ar = { 6, 4, 3, 7, 1, 9, 8 };
		int n = ar.length;
		int tmp;

//		pass는 n-1번 이루어진다.
		for (int i = 0; i < n - 1; i++) {
//			각 pass에서 비교 대상의 인덱스는 j-1과 j로 설정한다.
//			각 pass에서 j는 가장 끝 인덱스부터 i+1까지 1씩 감소하며 변화한다.
//			만약 pass가 2번 이루어진 경우 앞에서부터 2개의 요소가 정렬이 완료되었다.
//			이때 i는 2이고 정렬이 이루어지지 않은 요소의 인덱스는 i부터 가장 끝 인덱스 입니다.
//			따라서 각 pass에서 j는 가장 끝 인덱스(n-1)부터 1씩 감소하며 i+1까지 비교, 교환을 수행합니다.
			for (int j = n - 1; j >= i + 1; j--) {
				if (ar[j - 1] > ar[j]) {
					tmp = ar[j - 1];
					ar[j - 1] = ar[j];
					ar[j] = tmp;
				}
			}
		}

//		버블 정렬은 이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘으로
//		단순 교환 정렬(straight exchange sort)이라고도 합니다.

//		배열의 요소가 {6 4 7 9 1}인 경우를 예시로 들면

//		6과 4를 비교하고 앞에 있는 숫자가 뒤에 있는 숫자보다 클 경우 교환을 합니다.
//		{4 6 7 9 1}

//		이번에는 6과 7을 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크지 않으므로 교환하지 않습니다.
//		{4 6 7 9 1}

//		이번에는 7과 9를 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크지 않으므로 교환하지 않습니다.
//		{4 6 7 9 1}

//		이번에는 9와 1을 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크므로 교환을 합니다.
//		{4 6 7 1 9}

//		요솟수가 5개인 배열에서 4번 비교, 교환 하고 나면 가장 큰 요소가 맨 뒤로 이동합니다.
//		이런 일련의 과정(비교, 교환)을 패스라고 합니다.

//		이어서 배열의 가장 앞 요소부터 뒤에서 2번째 요소까지를 비교하는 패스를 수행합니다.

//		4와 6을 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크지 않으므로 교환하지 않습니다.
//		{4 6 7 1 9}

//		6과 7을 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크지 않으므로 교환하지 않습니다.
//		{4 6 7 1 9}

//		7과 1을 비교합니다. 앞에 있는 숫자가 뒤에 있는 숫자보다 크므로 교환합니다.
//		{4 6 1 7 9}

//		이 패스를 수행하고 나면 7은 배열의 뒤에서 2번째 자리로 이동하고 그 결과 총 2개 요소의 정렬이 끝납니다.
//		2번째 패스의 비교 횟수는 1번째 패스보다 1번 적은 3번 입니다.
//		왜냐하면 패스를 수행할 때마다 정렬해야할 요소가 하나씩 줄어들기 때문입니다.

//		요솟수가 5개인 배열을 정렬하는 패스의 횟수는 4번 입니다.
//		왜냐하면 패스를 4번 수행하면 뒤쪽부터 4개의 요소의 정렬이 끝나고 마지막 요소는 이미 가장 앞에 놓이기 때문입니다.

//		정리하자면
//		패스의 횟수를 추적하는 변수로는 i(i는 0부터 시작한다)를 사용한다.
//		요솟수가 n개인 배열을 정렬할 때 총 패스 횟수는 n-1번이다.
//		각 패스에서 비교대상이 되는 요소의 인덱스를 j와 j+1를 사용한다.
//		만약 패스가 2번 이루어진 경우 뒤에서부터 2개의 요소가 정렬이 완료된다.
//		이때 패스의 횟수를 추적하는 변수 i는 2이고
//		정렬이 이루어지지 않은 요소의 인덱스는 0부터 n-3 까지이다.
//		따라서 각 패스에서 j는 0부터 1씩 증가하면서 n-i-2 까지 비교, 교환을 수행한다.

//		int[] ar = { 6, 4, 7, 9, 1 };
//		int tmp;
//		int n = ar.length;

//		총 패스 횟수는 n-1번이다.
		for (int i = 0; i < n - 1; i++) {
//			각 패스에서 j는 0부터 1씩 증가하면서 n-i-1 까지 비교, 교환을 수행한다.
			for (int j = 0; j < n - i - 1; j++) {
				if (ar[j] > ar[j + 1]) {
					tmp = ar[j];
					ar[j] = ar[j + 1];
					ar[j + 1] = tmp;
				}
			}
		}

		for (int i = 0; i < n; i++) {
			System.out.print(ar[i] + " ");
		}
	}

}
